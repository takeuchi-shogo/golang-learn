# 29. cgo

## 核心ポイント
**Go ↔ C の境界越えは ~100-200ns。Go 関数呼び出しの100倍コスト。**

## cgo とは

Go から C のコードを呼び出す仕組み。`import "C"` と C コメントブロックを使う。

## なぜ遅いか

1. **スタック切り替え**: Go の goroutine スタック → C のスレッドスタック
2. **スケジューラとの連携**: M を P から切り離してシステムコール扱いにする
3. **GC 連携**: C のメモリは GC の管轄外
4. **シグナル処理**: Go のシグナルハンドラとの競合防止

## コスト比較

| 操作 | コスト |
|------|--------|
| Go 関数呼び出し | ~1-2ns |
| cgo 呼び出し | ~100-200ns |
| syscall | ~50-100ns |

## いつ cgo を使うべきか

- 既存の C ライブラリを使う必要がある（SQLite, OpenSSL 等）
- OS 固有の API にアクセスする

## いつ避けるべきか

- Pure Go の代替がある場合
- 高頻度で呼び出す場合（バッチ化を検討）
- クロスコンパイルが必要な場合（cgo はクロスコンパイルを複雑にする）

## ビルド

```bash
CGO_ENABLED=1 go build  # cgo 有効（デフォルト）
CGO_ENABLED=0 go build  # cgo 無効（static binary）
```

## 実行方法

```bash
CGO_ENABLED=1 go run ./29_cgo/
```
