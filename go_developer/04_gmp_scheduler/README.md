# 04. Goroutine Scheduling — G, M, P モデル

## 核心ポイント
**G=goroutine, M=OS thread, P=scheduler context。この3つで並行処理が回る。**

## G, M, P とは

```
┌─────────────────────────────────────┐
│              Go Runtime              │
│                                     │
│  ┌───┐ ┌───┐ ┌───┐      ┌───────┐ │
│  │ G │ │ G │ │ G │ ...  │Global │ │
│  └─┬─┘ └─┬─┘ └─┬─┘      │RunQ   │ │
│    │      │      │        └───────┘ │
│  ┌─▼──────▼──────▼─┐               │
│  │   P (Local RunQ) │  ← GOMAXPROCS 個 │
│  └────────┬─────────┘               │
│           │                         │
│  ┌────────▼─────────┐               │
│  │   M (OS Thread)   │              │
│  └───────────────────┘               │
└─────────────────────────────────────┘
```

### G (Goroutine)
- 軽量スレッド。初期スタック **2KB**（OS スレッドは 1-8MB）
- 状態: `_Grunnable`, `_Grunning`, `_Gwaiting`, `_Gsyscall`

### M (Machine)
- OS スレッド。実際に CPU 上で命令を実行する
- G を実行するには必ず P が必要

### P (Processor)
- スケジューラコンテキスト。ローカルランキューを持つ
- 数 = `GOMAXPROCS`（デフォルト: CPU コア数）

## スケジューリングの流れ

1. 新しい G が作られると、現在の P のローカルキューに入る
2. P のキューが一杯なら、グローバルキューに入る
3. M が G を実行し終わると、P のキューから次の G を取る
4. P のキューが空なら、**Work Stealing** で他の P から G を盗む
5. それでもなければ、グローバルキューからまとめて取る

## Work Stealing

```
P0: [G1, G2, G3, G4]    P1: []（空）
                              ↓ steal
P0: [G1, G2]            P1: [G3, G4]
```

キューの**後半**を盗む（FIFO の先頭はすぐ実行される可能性が高いため）。

## 実行方法

```bash
go run ./04_gmp_scheduler/
```
