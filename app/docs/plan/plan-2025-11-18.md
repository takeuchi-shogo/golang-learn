# 「竹」プラン - 認可ミドルウェア実装計画書

**作成日**: 2025-11-18

**プラン名**: 竹 - ミドルウェア化 + テスト充実

**おすすめ度**: ⭐⭐⭐⭐⭐

**規模感**: 半日〜1日

**ステータス**: 承認済み

---

## 📋 エグゼクティブサマリー

### 背景

現在、`PUT /users/{id}` エンドポイントには本人確認ロジックが実装されているが、`GET /users/{id}` は認証・認可なしでアクセス可能な状態。また、本人確認ロジックがルーター層に実装されており、保守性と拡張性に課題がある。

### 目的

- セキュリティ脆弱性の解消（GET /users/{id}の無防備状態）
- 認可ロジックの再利用性向上（ミドルウェア化）
- テストカバレッジの向上
- コードの保守性向上

### 期待される成果

- 認可ミドルウェアの新規作成
- GET /users/{id} への認証・認可の追加
- PUT /users/{id} のリファクタリング（ミドルウェアへの移行）
- 包括的なテストスイートの実装

---

## 🎯 プラン選定の経緯

### 検討したプラン

#### プラン① 「梅」- クイックフィックス

- **規模感**: 1-2時間
- **メリット**: 速攻で脆弱性を塞げる
- **デメリット**: 将来的な技術的負債、拡張性が低い
- **評価**: ❌ 選定されず

#### プラン② 「竹」- ミドルウェア化 + テスト充実（選定）

- **規模感**: 半日〜1日
- **メリット**: 再利用可能、保守性が高い、テストで安全性を証明
- **デメリット**: 実装時間がかかる
- **評価**: ✅ **選定** - バランスが最適

#### プラン③ 「松」- 完全リファクタリング + RBAC導入

- **規模感**: 2-3日
- **メリット**: 最も堅牢、スケーラブル
- **デメリット**: オーバーエンジニアリングのリスク
- **評価**: ❌ 選定されず（現時点では過剰投資）

### 選定理由

「竹」プランは、保守性と拡張性のバランスが良く、テストでセキュリティを証明できる。クイックフィックスだけでは将来的に技術的負債になり、完全リファクタリングは現段階では過剰投資と判断。

---

## 🔍 現状分析

### セキュリティ状況

#### ✅ 既存の対策

- `PUT /users/{id}` には本人確認ロジックが実装済み（router.go:147-158）
- JWT認証ミドルウェアが完璧に動作

#### 🚨 発見された問題

- `GET /users/{id}` が**完全に無防備**（誰でもアクセス可能）
- 他人のユーザー情報（名前、メールアドレス）が丸見え
- 本人確認ロジックがルーター層に散在（DRY違反）

### 技術的課題

1. **DRY違反**: 本人確認ロジックが複数箇所に重複
2. **責任の混在**: ルーター層がビジネスロジック（本人確認）を持つ
3. **テストしづらい**: ルーター層全体をテストしないと検証できない
4. **再利用できない**: 他のエンドポイント（DELETE、PATCHなど）で使えない

---

## 🎨 アーキテクチャ設計

### ミドルウェア設計

#### 関数シグネチャ

```go
// RequireOwnership はリソースの所有者のみがアクセスできることを保証するミドルウェア
// 引数:
//   - pathParamName: パスパラメータの名前 (例: "id")
// 戻り値: ミドルウェア関数
func RequireOwnership(pathParamName string) func(http.Handler) http.Handler
```

#### 処理フロー

1. Contextからログインユーザー情報を取得
2. パスパラメータからリソースIDを取得
3. リソースIDをUUIDにパース
4. ログインユーザーのSubをUUIDにパース
5. リソースIDとログインユーザーIDが一致するかチェック
6. 一致しない場合は403を返す
7. 一致する場合は次のハンドラーを実行

#### エラーハンドリング戦略

| エラー種別 | HTTPステータス | 説明 |
|-----------|---------------|------|
| Contextにユーザー情報なし | 401 Unauthorized | 認証ミドルウェアの実行漏れ |
| パスパラメータが不正 | 400 Bad Request | リクエスト形式エラー |
| UUIDパース失敗 | 400 Bad Request | リソースIDが不正 |
| Token内のUUID不正 | 401 Unauthorized | トークンデータ不正 |
| 所有者不一致 | 403 Forbidden | 権限なし |

### ミドルウェアチェーン設計

```go
// ✅ 正しい順序
mux.Handle("PUT /users/{id}",
    middleware.JwtVerify(jwtManager)(              // 1. JWT検証
        middleware.RequireOwnership("id")(         // 2. 所有者チェック
            http.HandlerFunc(updateUserRouter)     // 3. ビジネスロジック
        )
    )
)
```

**重要**: ミドルウェアは外側から内側に実行されるため、`JwtVerify` → `RequireOwnership` の順序が必須。

---

## 📦 実装内容

### 新規作成ファイル

#### 1. 認可ミドルウェア

- **ファイル**: `backend/internal/middleware/authorization.go`
- **機能**: 本人確認ロジックを実装
- **行数**: 約80行

#### 2. ミドルウェアテスト

- **ファイル**: `backend/internal/middleware/authorization_test.go`
- **テストケース数**: 6ケース
- **カバレッジ目標**: 100%

### 変更ファイル

#### 1. router.go

- **ファイル**: `backend/internal/infra/routes/router.go`
- **変更箇所**:
  - 48行目: GET /users/{id}にミドルウェア追加
  - 52行目: PUT /users/{id}にミドルウェア追加
  - 147-158行目: 本人確認ロジックの削除（12行削減）

#### 2. エンドポイントテスト

- **ファイル**: `backend/internal/infra/routes/user_routes_test.go` (新規)
- **ファイル**: `backend/internal/infra/routes/update_user_routes_test.go` (新規)
- **ファイル**: `backend/internal/infra/routes/test_helpers.go` (新規)

---

## ✅ テスト戦略

### テストケース一覧

#### 認可ミドルウェア（6ケース）

1. ✅ 本人のリソースにアクセス → 200 OK
2. ✅ 他人のリソースにアクセス → 403 Forbidden
3. ✅ Contextにユーザー情報がない → 401 Unauthorized
4. ✅ パスパラメータが不正なUUID → 400 Bad Request
5. ✅ トークン内のSubが不正なUUID → 401 Unauthorized
6. ✅ パスパラメータが存在しない → 400 Bad Request

#### GET /users/{id}（3ケース）

1. ✅ 認証あり + 本人のデータ取得 → 200 OK
2. ✅ 認証なし → 401 Unauthorized
3. ✅ 不正なID形式 → 400 Bad Request

#### PUT /users/{id}（6ケース）

1. ✅ 認証あり + 本人のデータ更新 → 200 OK
2. ✅ 認証あり + 他人のデータ更新試行 → 403 Forbidden
3. ✅ 認証なし → 401 Unauthorized
4. ✅ 不正なID形式 → 400 Bad Request
5. ✅ 不正なリクエストボディ → 400 Bad Request
6. ✅ バリデーションエラー → 400 Bad Request

**総計: 15テストケース**

### モック設計

```go
type MockJwtManager struct {
    VerifyTokenFunc func(ctx context.Context, tokenString string) (*jwt.Token, error)
    GetUserInfoFunc func(token *jwt.Token) (*jwtpkg.UserInfo, error)
}
```

### テストヘルパー関数

- `NewTestRequestBuilder()`: ビルダーパターンでリクエスト作成
- `CreateAuthenticatedRequest()`: 認証済みリクエストの簡易作成
- `AssertStatusCode()`: ステータスコードの検証
- `AssertErrorResponse()`: エラーレスポンスの検証

---

## 📅 実装スケジュール

### Phase 1: 基盤構築（1-2時間）

1. ✅ 認可ミドルウェアの仕様設計（30分）
2. ✅ `authorization.go`の作成（1時間）
3. ✅ `authorization_test.go`の作成（50分）

**チェックポイント**: 全テストがパス

### Phase 2: エンドポイントへの適用（1-2時間）

4. ✅ GET /users/{id}への適用（30分）
5. ✅ PUT /users/{id}のリファクタリング（40分）
6. ✅ 手動テスト（30分）

**チェックポイント**: GET/PUT両方が正常に動作

### Phase 3: 統合テスト（1-2時間）

7. ✅ GET /users/{id}の統合テスト作成（50分）
8. ✅ PUT /users/{id}の統合テスト更新（45分）
9. ✅ エッジケーステスト追加（40分）

**チェックポイント**: 全テストがパス、カバレッジ目標達成

### Phase 4: ドキュメント化（30分-1時間）

10. ✅ READMEの更新（30分）
11. ✅ 最終確認とコードレビュー（40分）

**チェックポイント**: 全てのドキュメントが最新

**合計所要時間**: 約7時間30分（半日〜1日）

---

## 🎯 成功指標

### 定量的指標

- [ ] テストカバレッジ: ミドルウェア 100%、エンドポイント 80%以上
- [ ] テストケース数: 15ケース以上
- [ ] コード削減: router.goで12行削減

### 定性的指標

- [ ] GET /users/{id}の脆弱性が解消
- [ ] 本人確認ロジックが再利用可能に
- [ ] コードの保守性が向上
- [ ] 全てのGoコーディング規約に準拠

---

## 🚨 リスクと対策

### リスク1: ミドルウェアチェーンの順序ミス

- **影響**: 認可が機能せず、401エラー多発
- **対策**: テストで順序を検証、コメントで順序を明記
- **優先度**: High

### リスク2: 既存機能の破壊

- **影響**: PUT /users/{id}が動作しなくなる
- **対策**: リファクタリング前後でテストを実行、段階的に移行
- **優先度**: High

### リスク3: パフォーマンス劣化

- **影響**: UUID parseのコストが増加
- **対策**: ベンチマークテスト、必要に応じてキャッシュ
- **優先度**: Low

---

## 💡 将来的な拡張性

### 短期的な拡張

- DELETE /users/{id}への適用
- PATCH /users/{id}への適用

### 中期的な拡張

- 管理者権限の実装（他人のデータも操作可能）
- ロールベースアクセス制御（RBAC）の検討

### 長期的な拡張

- 監査ログの実装
- ドメイン層への認可ロジック移行（Clean Architecture）

---

## 📚 参考資料

### 既存実装

- JWT認証ミドルウェア: `backend/internal/middleware/auth_middleware.go`
- JWT認証テスト: `backend/internal/middleware/auth_middleware_test.go`
- ルーター定義: `backend/internal/infra/routes/router.go`

### コーディング規約

- [Google Style Guide](https://google.github.io/styleguide/go/)
- [Effective Go](https://go.dev/doc/effective_go)
- [Uber Go Style Guide](https://github.com/uber-go/guide)

---

## 📝 承認履歴

| 日時 | 承認者 | ステータス | コメント |
|------|--------|----------|---------|
| 2025-11-18 | ユーザー | 承認 | 竹プランで進める。オーバーエンジニアリングは求めていない。 |

---

## 🎉 まとめ

「竹」プランは、セキュリティ脆弱性の解消と保守性向上を両立させる、バランスの取れた実装計画です。認可ミドルウェアの作成により、以下のメリットが得られます：

### メリット

1. **セキュリティ**: GET /users/{id}の脆弱性を解消
2. **保守性**: DRY原則に従い、ロジックを一箇所に集約
3. **再利用性**: 他のエンドポイントでも使用可能
4. **テスト性**: ミドルウェア単体でテスト可能
5. **拡張性**: 将来的なロール管理にも対応しやすい

### トレードオフ

- 実装時間がクイックフィックスより長い（半日〜1日）
- ミドルウェアチェーンの理解が必要
- 抽象化レイヤーが増える

**結論**: メリットがデメリットを大きく上回り、実装推奨。

---

**次のステップ**: Phase 1から実装を開始してください。
